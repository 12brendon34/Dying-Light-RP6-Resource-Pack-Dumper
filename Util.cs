using Microsoft.SqlServer.Server;
using System;
using System.IO;
using System.Text;

namespace DumpRP6
{
    internal class Util
    {

        //dumped from EResType and such
        /*
          	using T_EResType_GetName = char* (*)(int param_1);
	        auto EResType_GetName = *std::bit_cast<T_EResType_GetName>(std::bit_cast<uintptr_t>(Engine::Library) + 0x622f10); //this is the offset in DL 1.50.0.0 

	        const int maxResources = 260;

	        for (int i = 0; i < maxResources; ++i) {
		        const char* name = EResType_GetName(i);
		        if (name) {
			        std::cout << "Resource " << i << ": " << name << std::endl;
		        }
		        else {
			        std::cout << "Resource " << i << ": (null)" << std::endl;
		        }
	        }
        */

        //anything not in EResType::GetName I assume won't be in the rest of the base game

        //I should prob also store the actuall name such as _TEXTURE_BITMAP_DATA_
        public static string GetResourceName(int resourceTypeValue)
        {
            switch (resourceTypeValue)
            {
                //subtypes are usually generated by the compiler or seperated for some reason, not normal stuff like textures or meshes
                case 0: return "Invalid";
                case 16: return "Mesh";
                case 17: return "MeshFixups"; //subtype
                case 18: return "Skin";

                //not in EResType::GetName
                case 19: return "SkinFixups"; //subtype

                case 32: return "Texture";
                case 33: return "TextureBitmapData"; //subtype
                case 34: return "TextureMipBitmapData"; //subtype
                case 48: return "Material";
                case 49: return "Shader"; //subtype
                case 50: return "MaterialFixups"; //subtype
                case 51: return "MaterialTextures"; //subtype
                case 64: return "Animation";
                case 65: return "AnimationStream"; //subtype
                case 66: return "AnimationScr"; //subtype
                case 67: return "AnimationScrFixups"; //subtype

                case 68: return "ANM2_METADATA";
                case 69: return "ANM2_PAYLOAD";
                case 70: return "ANM2_FALLBACK";

                case 80: return "Fx";
                case 96: return "Lightmap";
                case 97: return "Flash";
                case 101: return "Sound";
                case 102: return "Music"; //subtype
                case 103: return "Speech"; //subtype
                case 104: return "SFX_stream"; //subtype
                case 105: return "SFX_local"; //subtype

                //not in EResType::GetName
                case 112: return "DensityMap";
                case 128: return "HeightMap";
                case 144: return "Mimics";
                case 160: return "PathMap";
                case 176: return "Phonemes";
                case 192: return "StaticGeometry";
                case 193: return "StaticGeomSetup"; //subtype
                case 194: return "StaticGeomFixups"; //subtype
                case 195: return "StaticGeomSetupFixups"; //subtype
                case 208: return "TextData";
                case 224: return "BinaryData";

                case 240: return "VertexData";
                case 241: return "IndexData";
                case 242: return "VertexDynamicData";
                case 248: return "TinyObjects";
                case 249: return "TinyObjectsFixUps"; //subtype
                case 250: return "TinyObjectsDensityMap"; //subtype
                case 255: return "BuilderInformation";

                default: return "Invalid";
            }
        }
        public enum ResourceType
        {
            Invalid = 0,

            // Mesh and related subtypes
            Mesh = 16,
            MeshFixups = 17, // subtype
            Skin = 18,
            SkinFixups = 19, // subtype

            // Texture and related subtypes
            Texture = 32,
            TextureBitmapData = 33, // subtype
            TextureMipBitmapData = 34, // subtype

            // Material and related subtypes
            Material = 48,
            Shader = 49, // subtype
            MaterialFixups = 50, // subtype
            MaterialTextures = 51, // subtype

            // Animation and related subtypes
            Animation = 64,
            AnimationStream = 65, // subtype
            AnimationScr = 66, // subtype
            AnimationScrFixups = 67, // subtype

            // ANM2 Metadata and payloads
            ANM2_METADATA = 68,
            ANM2_PAYLOAD = 69,
            ANM2_FALLBACK = 70,

            // Effects
            Fx = 80,

            // Lightmaps and other visual resources
            Lightmap = 96,
            Flash = 97,

            // Sound and related subtypes
            Sound = 101,
            Music = 102, // subtype
            Speech = 103, // subtype
            SFX_stream = 104, // subtype
            SFX_local = 105, // subtype

            // Additional resources not in EResType::GetName
            DensityMap = 112,
            HeightMap = 128,
            Mimics = 144,
            PathMap = 160,
            Phonemes = 176,

            // Static Geometry and related subtypes
            StaticGeometry = 192,
            StaticGeomSetup = 193, // subtype
            StaticGeomFixups = 194, // subtype
            StaticGeomSetupFixups = 195, // subtype

            // Data resources
            TextData = 208,
            BinaryData = 224,

            // Vertex and Index data
            VertexData = 240,
            IndexData = 241,
            VertexDynamicData = 242,

            // Tiny Objects and related subtypes
            TinyObjects = 248,
            TinyObjectsFixUps = 249, // subtype
            TinyObjectsDensityMap = 250, // subtype

            // Builder Information
            BuilderInformation = 255
        }


        //I was wrong, Don't use this
        //CRenderer::SortDisplayMode
        //or basically just search memory for R8G8B8 in engine dll

        //the actual location of this data is in imagelib
        //IL_FormatFromStr does the trick
        public enum TextureFormat : uint
        {
            R8G8B8 = 0,
            B8G8R8 = 1,
            A8R8G8B8 = 2,
            X8R8G8B8 = 3,
            B8G8R8X8 = 4,
            B8G8R8A8 = 5,
            A8B8G8R8 = 6,
            X8B8G8R8 = 7,
            R5G6B5 = 8,
            X1R5G5B5 = 9,
            A1R5G5B5 = 10,
            A4R4G4B4 = 0xb,
            X4R4G4B4 = 0xc,
            A8 = 0xd,
            L8 = 0xe,
            A8L8 = 0xf,
            A4L4 = 0x10,
            DXT1 = 0x11,
            DXT3 = 0x12,
            DXT5 = 0x13,
            V8U8 = 0x14,
            L6V5U5 = 0x15,
            X8L8V8U8 = 0x16,
            Q8W8V8U8 = 0x17,
            CxV8U8 = 0x18,
            L16 = 0x19,
            G16R16 = 0x1a,
            A16B16G16R16 = 0x1b,
            R16F = 0x1c,
            G16R16F = 0x1d,
            A16B16G16R16F = 0x1e,
            R32F = 0x1f,
            G32R32F = 0x20,
            A32B32G32R32F = 0x21,
            D16 = 0x22,
            D24S8 = 0x23,
            D16S8 = 0x61,
            D24X8 = 0x24,
            D32 = 0x25,
            DF16 = 0x26,
            DF24 = 0x27,
            D24FS8 = 0x28,
            D32FS8 = 0x5d,
            XENON_HDR_16FF = 0x29,
            XENON_HDR_16F = 0x2a,
            XENON_HDR_16 = 0x2b,
            XENON_HDR_8 = 0x2c,
            DXT3A = 0x2d,
            DXT5A = 0x2e,
            DXN = 0x2f,
            CTX1 = 0x30,
            DXT3A_1111 = 0x31,
            XENON_HDR_10 = 0x32,
            XENON_HDR_11 = 0x33,
            A2R10G10B10 = 0x34,
            R11G11B10 = 0x35,
            A8R8G8B8_GAMMA = 0x36,
            A8R8G8B8_GAMMA_AS16 = 0x37,
            A2R10G10B10_GAMMA = 0x38,
            A2R10G10B10_GAMMA_AS16 = 0x39,
            B32G32R32F = 0x3a,
            R11G11B10F = 0x3b,
            UNKNOWN = 0xffff,
            R32G32B32A32_UINT = 0x3c,
            R32G32B32A32_SINT = 0x3d,
            R16G16B16A16_SNORM = 0x3f,
            R16G16B16A16_UINT = 0x3e,
            R16G16B16A16_SINT = 0x40,
            R32G32_UINT = 0x41,
            R32G32_SINT = 0x42,
            R10G10B10A2_UNORM = 0x43,
            R10G10B10A2_UINT = 0x44,
            R8G8B8A8_SNORM = 0x46,
            R8G8B8A8_UINT = 0x45,
            R8G8B8A8_SINT = 0x47,
            R16G16_SNORM = 0x49,
            R16G16_UINT = 0x48,
            R16G16_SINT = 0x4a,
            R32_UINT = 0x4b,
            R32_SINT = 0x4c,
            R8G8_UNORM = 0x4d,
            R8G8_SNORM = 0x4f,
            R8G8_UINT = 0x4e,
            R8G8_SINT = 0x50,
            R16_UNORM = 0x51,
            R16_SNORM = 0x53,
            R16_UINT = 0x52,
            R16_SINT = 0x54,
            R8_UNORM = 0x55,
            R8_UINT = 0x56,
            R8_SNORM = 0x57,
            R8_SINT = 0x58,
            BC5_SNORM = 0x59,
            R32_FLOAT_X8X24_TYPELESS = 0x5a,
            X32_TYPELESS_G8X24_UINT = 0x5b,
            X24_TYPELESS_G8_UINT = 0x5c,
            BC6H_UF16 = 0x5e,
            BC6H_SF16 = 0x5f,
            BC7_UNORM = 0x60
        }

        public static DDS.DXGI_FORMAT GetDXGIFormat(TextureFormat textureFormat)
        {
            switch (textureFormat)
            {
                //Tested Functional
                case TextureFormat.A1R5G5B5:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM;
                case TextureFormat.A8B8G8R8:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM;
                case TextureFormat.A8R8G8B8:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM;
                case TextureFormat.R5G6B5:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM;

                //compressed formats
                case TextureFormat.DXT1:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM;
                case TextureFormat.DXT3:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM;   
                case TextureFormat.DXT5:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM;

                //Untested
                //Compressed
                case TextureFormat.BC5_SNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_BC5_SNORM;
                case TextureFormat.BC6H_UF16:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_BC6H_UF16;
                case TextureFormat.BC6H_SF16:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_BC6H_SF16;
                case TextureFormat.BC7_UNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_BC7_UNORM;

                //grouped bc they had the same bit masks, not really important
                case TextureFormat.D16:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_D16_UNORM;
                case TextureFormat.DF16:
                case TextureFormat.R16F:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16_FLOAT;
                case TextureFormat.L16:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM;

                case TextureFormat.X8R8G8B8:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_B8G8R8X8_UNORM;

                case TextureFormat.B8G8R8X8:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_B8G8R8X8_UNORM;

                case TextureFormat.B8G8R8A8:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM;

                case TextureFormat.X1R5G5B5:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM;

                case TextureFormat.A8:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_A8_UNORM;

                case TextureFormat.L8:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM;

                case TextureFormat.A8L8:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM;

                case TextureFormat.V8U8:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_SNORM;

                case TextureFormat.G16R16:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM;

                case TextureFormat.A16B16G16R16:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16B16A16_UNORM;

                case TextureFormat.G16R16F:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_FLOAT;

                case TextureFormat.A16B16G16R16F:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16B16A16_FLOAT;

                case TextureFormat.R32F:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT;

                case TextureFormat.G32R32F:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R32G32_FLOAT;

                case TextureFormat.A32B32G32R32F:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R32G32B32A32_FLOAT;

                case TextureFormat.D24S8:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_D24_UNORM_S8_UINT;

                case TextureFormat.D24X8:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R24_UNORM_X8_TYPELESS;

                case TextureFormat.D32:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_D32_FLOAT;

                case TextureFormat.A2R10G10B10:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM;

                case TextureFormat.R11G11B10:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R11G11B10_FLOAT;

                case TextureFormat.R32G32B32A32_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R32G32B32A32_UINT;

                case TextureFormat.R32G32B32A32_SINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R32G32B32A32_SINT;

                case TextureFormat.R16G16B16A16_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16B16A16_UINT;

                case TextureFormat.R16G16B16A16_SNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16B16A16_SNORM;

                case TextureFormat.R16G16B16A16_SINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16B16A16_SINT;

                case TextureFormat.R32G32_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R32G32_UINT;

                case TextureFormat.R32G32_SINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R32G32_SINT;

                case TextureFormat.R10G10B10A2_UNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM;

                case TextureFormat.R10G10B10A2_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UINT;

                case TextureFormat.R8G8B8A8_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UINT;

                case TextureFormat.R8G8B8A8_SNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_SNORM;

                case TextureFormat.R8G8B8A8_SINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_SINT;

                case TextureFormat.R16G16_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_UINT;

                case TextureFormat.R16G16_SNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_SNORM;

                case TextureFormat.R16G16_SINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_SINT;

                case TextureFormat.R32_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R32_UINT;

                case TextureFormat.R32_SINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R32_SINT;

                case TextureFormat.R8G8_UNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM;

                case TextureFormat.R8G8_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_UINT;

                case TextureFormat.R8G8_SNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_SNORM;

                case TextureFormat.R8G8_SINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_SINT;

                case TextureFormat.R16_UNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM;

                case TextureFormat.R16_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16_UINT;

                case TextureFormat.R16_SNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16_SNORM;

                case TextureFormat.R16_SINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R16_SINT;

                case TextureFormat.R8_UNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM;

                case TextureFormat.R8_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8_UINT;

                case TextureFormat.R8_SNORM:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8_SNORM;

                case TextureFormat.R8_SINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R8_SINT;

                case TextureFormat.R32_FLOAT_X8X24_TYPELESS:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS;

                case TextureFormat.X32_TYPELESS_G8X24_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT;

                case TextureFormat.X24_TYPELESS_G8_UINT:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_X24_TYPELESS_G8_UINT;

                //not a supported format, accidently grabbed a display mode
                //case TextureFormat.D32_FLOAT_S8X24_UINT:
                //    return DDS.DXGI_FORMAT.DXGI_FORMAT_D32_FLOAT_S8X24_UINT;
                    
                default:
                    return DDS.DXGI_FORMAT.DXGI_FORMAT_UNKNOWN;
            }
        }

        public static StringBuilder FormatFX(string[] raw)
        {
            //remove everything before the ACK character as it's not intended
            int ackIndex = raw[0].IndexOf('\x06');
            if (ackIndex != -1)
            {
                raw[0] = raw[0].Substring(ackIndex + 1).Trim();
            }

            // Remove trailing NUL characters from the last line
            if (raw.Length > 0)
            {
                raw[raw.Length - 1] = raw[raw.Length - 1].TrimEnd('\x00');
            }

            var output = new StringBuilder();

            int indentLevel = 0;
            char indentString = '\t'; // tab, matches offical

            for (int i = 0; i < raw.Length; i++)
            {

                string trimmedLine = raw[i].Trim();

                if (trimmedLine.EndsWith("{") || trimmedLine == "{")
                {
                    output.AppendLine(new string(indentString, indentLevel) + trimmedLine);
                    indentLevel++;
                }
                else if (trimmedLine == "}")
                {
                    indentLevel--;
                    output.AppendLine(new string(indentString, indentLevel) + trimmedLine);
                    output.AppendLine();
                }
                else
                {
                    output.AppendLine(new string(indentString, indentLevel) + trimmedLine);

                    // Add an empty line if the next line is not a brace and the current line ends with ()
                    if (i + 1 < raw.Length && !raw[i + 1].Trim().StartsWith("{") && trimmedLine.EndsWith("()"))
                    {
                        output.AppendLine();
                    }
                }
            }

            return output;
        }

        public static string ReadString(Stream stream, Encoding encoding, int size)
        {
            using (BinaryReader reader = new BinaryReader(stream, Encoding.Default, leaveOpen: true))
            {
                byte[] array = reader.ReadBytes(size);

                // Check for incomplete reads
                if (array.Length != size)
                {
                    throw new EndOfStreamException("Unexpected end of stream while reading string.");
                }

                return encoding.GetString(array);
            }
        }
        public static string ReadStringNull(Stream stream, Encoding encoding)
        {
            using (MemoryStream buffer = new MemoryStream())
            {
                int byteRead;
                while ((byteRead = stream.ReadByte()) > 0) // Read until null terminator (0)
                {
                    buffer.WriteByte((byte)byteRead);
                }

                if (byteRead == -1 && buffer.Length == 0)
                {
                    throw new EndOfStreamException("Unexpected end of stream while reading string.");
                }

                return encoding.GetString(buffer.ToArray());
            }
        }

        public static uint ReadValueU32(Stream stream)
        {
            using (BinaryReader reader = new BinaryReader(stream, Encoding.Default, leaveOpen: true))
            {
                return reader.ReadUInt32();
            }
        }

        public static ushort ReadValueU16(Stream stream)
        {
            using (BinaryReader reader = new BinaryReader(stream, Encoding.Default, leaveOpen: true))
            {
                return reader.ReadUInt16();
            }
        }

        public static byte ReadByte(Stream stream)
        {
            using (BinaryReader reader = new BinaryReader(stream, Encoding.Default, leaveOpen: true))
            {
                return reader.ReadByte();
            }
        }

        public static void WriteU32(FileStream stream, uint value)
        {
            byte[] bytes = BitConverter.GetBytes(value);
            if (!BitConverter.IsLittleEndian)
            {
                Array.Reverse(bytes);
            }
            stream.Write(bytes, 0, bytes.Length);
        }
    }
}
