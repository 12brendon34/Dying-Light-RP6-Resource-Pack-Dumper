using System;
using System.IO;
using System.Text;

namespace DumpRP6
{
    internal class Util
    {

        //dumped from EResType and such
        /*
          	using T_EResType_GetName = char* (*)(int param_1);
	        auto EResType_GetName = *std::bit_cast<T_EResType_GetName>(std::bit_cast<uintptr_t>(Engine::Library) + 0x622f10); //this is the offset in DL 1.50.0.0 

	        const int maxResources = 260;

	        for (int i = 0; i < maxResources; ++i) {
		        const char* name = EResType_GetName(i);
		        if (name) {
			        std::cout << "Resource " << i << ": " << name << std::endl;
		        }
		        else {
			        std::cout << "Resource " << i << ": (null)" << std::endl;
		        }
	        }
        */

        //anything not in EResType::GetName I assume won't be in the rest of the base game

        //I should prob also store the actuall name such as _TEXTURE_BITMAP_DATA_
        public static string GetResourceName(int resourceTypeValue)
        {
            switch (resourceTypeValue)
            {
                //subtypes are usually generated by the compiler or seperated for some reason, not normal stuff like textures or meshes
                case 0: return "Invalid";
                case 16: return "Mesh";
                case 17: return "MeshFixups"; //subtype
                case 18: return "Skin";

                //not in EResType::GetName
                case 19: return "SkinFixups"; //subtype

                case 32: return "Texture";
                case 33: return "TextureBitmapData"; //subtype
                case 34: return "TextureMipBitmapData"; //subtype
                case 48: return "Material";
                case 49: return "Shader"; //subtype
                case 50: return "MaterialFixups"; //subtype
                case 51: return "MaterialTextures"; //subtype
                case 64: return "Animation";
                case 65: return "AnimationStream"; //subtype
                case 66: return "AnimationScr"; //subtype
                case 67: return "AnimationScrFixups"; //subtype

                case 68: return "ANM2_METADATA";
                case 69: return "ANM2_PAYLOAD";
                case 70: return "ANM2_FALLBACK";

                case 80: return "Fx";
                case 96: return "Lightmap";
                case 97: return "Flash";
                case 101: return "Sound";
                case 102: return "Music"; //subtype
                case 103: return "Speech"; //subtype
                case 104: return "SFX_stream"; //subtype
                case 105: return "SFX_local"; //subtype

                //not in EResType::GetName
                case 112: return "DensityMap";
                case 128: return "HeightMap";
                case 144: return "Mimics";
                case 160: return "PathMap";
                case 176: return "Phonemes";
                case 192: return "StaticGeometry";
                case 193: return "StaticGeomSetup"; //subtype
                case 194: return "StaticGeomFixups"; //subtype
                case 195: return "StaticGeomSetupFixups"; //subtype
                case 208: return "TextData";
                case 224: return "BinaryData";

                case 240: return "VertexData";
                case 241: return "IndexData";
                case 242: return "VertexDynamicData";
                case 248: return "TinyObjects";
                case 249: return "TinyObjectsFixUps"; //subtype
                case 250: return "TinyObjectsDensityMap"; //subtype
                case 255: return "BuilderInformation";

                default: return "Invalid";
            }
        }
        public enum ResourceType
        {
            Invalid = 0,

            // Mesh and related subtypes
            Mesh = 16,
            MeshFixups = 17, // subtype
            Skin = 18,
            SkinFixups = 19, // subtype

            // Texture and related subtypes
            Texture = 32,
            TextureBitmapData = 33, // subtype
            TextureMipBitmapData = 34, // subtype

            // Material and related subtypes
            Material = 48,
            Shader = 49, // subtype
            MaterialFixups = 50, // subtype
            MaterialTextures = 51, // subtype

            // Animation and related subtypes
            Animation = 64,
            AnimationStream = 65, // subtype
            AnimationScr = 66, // subtype
            AnimationScrFixups = 67, // subtype

            // ANM2 Metadata and payloads
            ANM2_METADATA = 68,
            ANM2_PAYLOAD = 69,
            ANM2_FALLBACK = 70,

            // Effects
            Fx = 80,

            // Lightmaps and other visual resources
            Lightmap = 96,
            Flash = 97,

            // Sound and related subtypes
            Sound = 101,
            Music = 102, // subtype
            Speech = 103, // subtype
            SFX_stream = 104, // subtype
            SFX_local = 105, // subtype

            // Additional resources not in EResType::GetName
            DensityMap = 112,
            HeightMap = 128,
            Mimics = 144,
            PathMap = 160,
            Phonemes = 176,

            // Static Geometry and related subtypes
            StaticGeometry = 192,
            StaticGeomSetup = 193, // subtype
            StaticGeomFixups = 194, // subtype
            StaticGeomSetupFixups = 195, // subtype

            // Data resources
            TextData = 208,
            BinaryData = 224,

            // Vertex and Index data
            VertexData = 240,
            IndexData = 241,
            VertexDynamicData = 242,

            // Tiny Objects and related subtypes
            TinyObjects = 248,
            TinyObjectsFixUps = 249, // subtype
            TinyObjectsDensityMap = 250, // subtype

            // Builder Information
            BuilderInformation = 255
        }
        public enum TextureFormat : uint
        {
            R8G8B8 = 0,
            B8G8R8 = 1,
            A8R8G8B8 = 2,
            X8R8G8B8 = 3,
            B8G8R8X8 = 4,
            B8G8R8A8 = 5,
            A8B8G8R8 = 6,
            X8B8G8R8 = 7,
            R5G6B5 = 8,
            X1R5G5B5 = 9,
            A1R5G5B5 = 10,
            A4R4G4B4 = 11,
            X4R4G4B4 = 12,
            A8 = 13,
            L8 = 14,
            A8L8 = 15,
            A4L4 = 16,
            DXT1 = 17,
            DXT3 = 18,
            DXT5 = 19,
            V8U8 = 20,
            L6V5U5 = 21,
            X8L8V8U8 = 22,
            Q8W8V8U8 = 23,
            CxV8U8 = 24,
            L16 = 25,
            G16R16 = 26,
            A16B16G16R16 = 27,
            R16F = 28,
            G16R16F = 29,
            A16B16G16R16F = 30,
            R32F = 31,
            G32R32F = 32,
            A32B32G32R32F = 33,
            D16 = 34,
            D24S8 = 35,
            D24X8 = 36,
            D32 = 37,
            DF16 = 38,
            DF24 = 39,
            D24FS8 = 40,
            XENON_HDR_16FF = 41,
            XENON_HDR_16F = 42,
            XENON_HDR_16 = 43,
            XENON_HDR_8 = 44,
            DXT3A = 45,
            DXT5A = 46,
            DXN = 47,
            CTX1 = 48,
            DXT3A_1111 = 49,
            XENON_HDR_10 = 50,
            XENON_HDR_11 = 51,
            A2R10G10B10 = 52,
            R11G11B10 = 53,
            A8R8G8B8_GAMMA = 54,
            A8R8G8B8_GAMMA_AS16 = 55,
            A2R10G10B10_GAMMA = 56,
            A2R10G10B10_GAMMA_AS16 = 57,
        }
        public static StringBuilder FormatFX(string[] raw)
        {
            //remove everything before the ACK character as it's not intended
            int ackIndex = raw[0].IndexOf('\x06');
            if (ackIndex != -1)
            {
                raw[0] = raw[0].Substring(ackIndex + 1).Trim();
            }

            // Remove trailing NUL characters from the last line
            if (raw.Length > 0)
            {
                raw[raw.Length - 1] = raw[raw.Length - 1].TrimEnd('\x00');
            }

            var output = new StringBuilder();

            int indentLevel = 0;
            char indentString = '\t'; // tab, matches offical

            for (int i = 0; i < raw.Length; i++)
            {

                string trimmedLine = raw[i].Trim();

                if (trimmedLine.EndsWith("{") || trimmedLine == "{")
                {
                    output.AppendLine(new string(indentString, indentLevel) + trimmedLine);
                    indentLevel++;
                }
                else if (trimmedLine == "}")
                {
                    indentLevel--;
                    output.AppendLine(new string(indentString, indentLevel) + trimmedLine);
                    output.AppendLine();
                }
                else
                {
                    output.AppendLine(new string(indentString, indentLevel) + trimmedLine);

                    // Add an empty line if the next line is not a brace and the current line ends with ()
                    if (i + 1 < raw.Length && !raw[i + 1].Trim().StartsWith("{") && trimmedLine.EndsWith("()"))
                    {
                        output.AppendLine();
                    }
                }
            }

            return output;
        }

        public static string ReadString(Stream stream, Encoding encoding, int size)
        {
            using (BinaryReader reader = new BinaryReader(stream, Encoding.Default, leaveOpen: true))
            {
                byte[] array = reader.ReadBytes(size);

                // Check for incomplete reads
                if (array.Length != size)
                {
                    throw new EndOfStreamException("Unexpected end of stream while reading string.");
                }

                return encoding.GetString(array);
            }
        }
        public static string ReadStringNull(Stream stream, Encoding encoding)
        {
            using (MemoryStream buffer = new MemoryStream())
            {
                int byteRead;
                while ((byteRead = stream.ReadByte()) > 0) // Read until null terminator (0)
                {
                    buffer.WriteByte((byte)byteRead);
                }

                if (byteRead == -1 && buffer.Length == 0)
                {
                    throw new EndOfStreamException("Unexpected end of stream while reading string.");
                }

                return encoding.GetString(buffer.ToArray());
            }
        }

        public static uint ReadValueU32(Stream stream)
        {
            using (BinaryReader reader = new BinaryReader(stream, Encoding.Default, leaveOpen: true))
            {
                return reader.ReadUInt32();
            }
        }

        public static ushort ReadValueU16(Stream stream)
        {
            using (BinaryReader reader = new BinaryReader(stream, Encoding.Default, leaveOpen: true))
            {
                return reader.ReadUInt16();
            }
        }

        public static byte ReadByte(Stream stream)
        {
            using (BinaryReader reader = new BinaryReader(stream, Encoding.Default, leaveOpen: true))
            {
                return reader.ReadByte();
            }
        }

        public static void WriteU32(FileStream stream, uint value)
        {
            byte[] bytes = BitConverter.GetBytes(value);
            if (!BitConverter.IsLittleEndian)
            {
                Array.Reverse(bytes);
            }
            stream.Write(bytes, 0, bytes.Length);
        }
    }
}
