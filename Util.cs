using System.IO;
using System.Text;

namespace DumpRP6
{
    internal class Util
    {

        //dumped from EResType and such
        /*
          	using T_EResType_GetName = char* (*)(int param_1);
	        auto EResType_GetName = *std::bit_cast<T_EResType_GetName>(std::bit_cast<uintptr_t>(Engine::Library) + 0x622f10); //this is the offset in DL 1.50.0.0 

	        const int maxResources = 260;

	        for (int i = 0; i < maxResources; ++i) {
		        const char* name = EResType_GetName(i);
		        if (name) {
			        std::cout << "Resource " << i << ": " << name << std::endl;
		        }
		        else {
			        std::cout << "Resource " << i << ": (null)" << std::endl;
		        }
	        }
        */

        //anything not in EResType::GetName I assume won't be in the rest of the base game

        //I should prob also store the actuall name such as _TEXTURE_BITMAP_DATA_
        public static string GetResourceName(int resourceTypeValue)
        {
            switch (resourceTypeValue)
            {
                //subtypes are usually generated by the compiler or seperated for some reason, not normal stuff like textures or meshes
                case 0: return "Invalid";
                case 16: return "Mesh";
                case 17: return "MeshFixups"; //subtype
                case 18: return "Skin";

                //not in EResType::GetName
                case 19: return "SkinFixups"; //subtype

                case 32: return "Texture";
                case 33: return "TextureBitmapData"; //subtype
                case 34: return "TextureMipBitmapData"; //subtype
                case 48: return "Material";
                case 49: return "Shader"; //subtype
                case 50: return "MaterialFixups"; //subtype
                case 51: return "MaterialTextures"; //subtype
                case 64: return "Animation";
                case 65: return "AnimationStream"; //subtype
                case 66: return "AnimationScr"; //subtype
                case 67: return "AnimationScrFixups"; //subtype

                case 68: return "ANM2_METADATA";
                case 69: return "ANM2_PAYLOAD";
                case 70: return "ANM2_FALLBACK";

                case 80: return "Fx";
                case 96: return "Lightmap";
                case 97: return "Flash";
                case 101: return "Sound";
                case 102: return "Music"; //subtype
                case 103: return "Speech"; //subtype
                case 104: return "SFX_stream"; //subtype
                case 105: return "SFX_local"; //subtype

                //not in EResType::GetName
                case 112: return "DensityMap";
                case 128: return "HeightMap";
                case 144: return "Mimics";
                case 160: return "PathMap";
                case 176: return "Phonemes";
                case 192: return "StaticGeometry";
                case 193: return "StaticGeomSetup"; //subtype
                case 194: return "StaticGeomFixups"; //subtype
                case 195: return "StaticGeomSetupFixups"; //subtype
                case 208: return "TextData";
                case 224: return "BinaryData";

                case 240: return "VertexData";
                case 241: return "IndexData";
                case 242: return "VertexDynamicData";
                case 248: return "TinyObjects";
                case 249: return "TinyObjectsFixUps"; //subtype
                case 250: return "TinyObjectsDensityMap"; //subtype
                case 255: return "BuilderInformation";

                default: return "Invalid";
            }
        }
        public enum ResourceType
        {
            Invalid = 0,

            // Mesh and related subtypes
            Mesh = 16,
            MeshFixups = 17, // subtype
            Skin = 18,
            SkinFixups = 19, // subtype

            // Texture and related subtypes
            Texture = 32,
            TextureBitmapData = 33, // subtype
            TextureMipBitmapData = 34, // subtype

            // Material and related subtypes
            Material = 48,
            Shader = 49, // subtype
            MaterialFixups = 50, // subtype
            MaterialTextures = 51, // subtype

            // Animation and related subtypes
            Animation = 64,
            AnimationStream = 65, // subtype
            AnimationScr = 66, // subtype
            AnimationScrFixups = 67, // subtype

            // ANM2 Metadata and payloads
            ANM2_METADATA = 68,
            ANM2_PAYLOAD = 69,
            ANM2_FALLBACK = 70,

            // Effects
            Fx = 80,

            // Lightmaps and other visual resources
            Lightmap = 96,
            Flash = 97,

            // Sound and related subtypes
            Sound = 101,
            Music = 102, // subtype
            Speech = 103, // subtype
            SFX_stream = 104, // subtype
            SFX_local = 105, // subtype

            // Additional resources not in EResType::GetName
            DensityMap = 112,
            HeightMap = 128,
            Mimics = 144,
            PathMap = 160,
            Phonemes = 176,

            // Static Geometry and related subtypes
            StaticGeometry = 192,
            StaticGeomSetup = 193, // subtype
            StaticGeomFixups = 194, // subtype
            StaticGeomSetupFixups = 195, // subtype

            // Data resources
            TextData = 208,
            BinaryData = 224,

            // Vertex and Index data
            VertexData = 240,
            IndexData = 241,
            VertexDynamicData = 242,

            // Tiny Objects and related subtypes
            TinyObjects = 248,
            TinyObjectsFixUps = 249, // subtype
            TinyObjectsDensityMap = 250, // subtype

            // Builder Information
            BuilderInformation = 255
        }

        public static StringBuilder FormatFX(string[] raw)
        {
            //remove everything before the ACK character as it's not intended
            int ackIndex = raw[0].IndexOf('\x06');
            if (ackIndex != -1)
            {
                raw[0] = raw[0].Substring(ackIndex + 1).Trim();
            }

            // Remove trailing NUL characters from the last line
            if (raw.Length > 0)
            {
                raw[raw.Length - 1] = raw[raw.Length - 1].TrimEnd('\x00');
            }

            var output = new StringBuilder();

            int indentLevel = 0;
            char indentString = '\t'; // tab, matches offical

            for (int i = 0; i < raw.Length; i++)
            {

                string trimmedLine = raw[i].Trim();

                if (trimmedLine.EndsWith("{") || trimmedLine == "{")
                {
                    output.AppendLine(new string(indentString, indentLevel) + trimmedLine);
                    indentLevel++;
                }
                else if (trimmedLine == "}")
                {
                    indentLevel--;
                    output.AppendLine(new string(indentString, indentLevel) + trimmedLine);
                    output.AppendLine();
                }
                else
                {
                    output.AppendLine(new string(indentString, indentLevel) + trimmedLine);

                    // Add an empty line if the next line is not a brace and the current line ends with ()
                    if (i + 1 < raw.Length && !raw[i + 1].Trim().StartsWith("{") && trimmedLine.EndsWith("()"))
                    {
                        output.AppendLine();
                    }
                }
            }

            return output;
        }

        public static string ReadString(Stream stream, Encoding encoding, int size)
        {
            using (BinaryReader reader = new BinaryReader(stream, Encoding.Default, leaveOpen: true))
            {
                byte[] array = reader.ReadBytes(size);

                // Check for incomplete reads
                if (array.Length != size)
                {
                    throw new EndOfStreamException("Unexpected end of stream while reading string.");
                }

                return encoding.GetString(array);
            }
        }
        public static string ReadStringNull(Stream stream, Encoding encoding)
        {
            using (MemoryStream buffer = new MemoryStream())
            {
                int byteRead;
                while ((byteRead = stream.ReadByte()) > 0) // Read until null terminator (0)
                {
                    buffer.WriteByte((byte)byteRead);
                }

                if (byteRead == -1 && buffer.Length == 0)
                {
                    throw new EndOfStreamException("Unexpected end of stream while reading string.");
                }

                return encoding.GetString(buffer.ToArray());
            }
        }

        public static uint ReadValueU32(Stream stream)
        {
            using (BinaryReader reader = new BinaryReader(stream, Encoding.Default, leaveOpen: true))
            {
                return reader.ReadUInt32();
            }
        }
    }
}
